%% toy data generation
xx=(x([10000:60000],:));
xx  = gain * double(xx);
%% Toy filtering
Lpass=300;
Hstop=3000;
fBand=[Lpass/(Fs/2),Hstop/(Fs/2)];% normalization of frequency limits
[b,a]=cheby2(7,50,fBand,'bandpass');
xx=filtfilt(b,a,xx);
%% Threshold detection
sigma=median(abs(xx)./0.6745); % sigma is the estimated standard deviation 
for i = 1:4
    input=xx(:,i); %avoid bugs
    Spiketouch=[1]; % create a recorder of the number of spikes reached the threshold
    N=2; % initial N value, Threshold should be N*sigma
    while Spiketouch~= 0
        Spiketouch=length(input(input<(-N).*sigma(i))); % record # of spikes reached the threshold
        N=N+1; %the N number will keep increasing until no spike reach the threshold.(N-1)*sigma will be the high threshold, 1*sigma will be the low threshold
    end
Thre(i)=-N/2*sigma(i); % The threshold equals to ((N-1)+1)/2, which is the average value of high and low threshold value.
end
%% Nash's method for spike detection, just for temporal solution, should stick on Julian's code
residual=xx-repmat(Thre,length(xx),1);
residual(residual<0)=-1;
residual(residual>0)=1;
re1=[residual;zeros(1,4)];
re2=[zeros(1,4);residual];
cross=re1-re2;
spikes=[xx;zeros(1,4)];
spikes(cross<=0)=0;
spikes(50002,:)=[];
%% Julian's method for spikes detection
N_elec=size(xx); %determinethe size of the input data
Spikes = zeros(N_elec(1), N_elec(2));%create an array with zeros matching the dimensions of the data matrix
for j = 1:N_elec(2) %go through all four channels
    Pre_Spikes = find(xx(:,j)<=Thre(j)); %find over threshold indices
    for u = 1: length(Pre_Spikes)%go through the whole crossing for one channel
        if u == 1
            Spikes(Pre_Spikes(u),j) = 1; %put the information of a crossing in a file
        elseif xx(Pre_Spikes(u)-1)>Thre(j) && xx(Pre_Spikes(u))<Thre(j) %check that there is only one crossing per 
            Spikes(Pre_Spikes(u),j) = 1; %put the information of a crossing in a file
        end
    end
end
